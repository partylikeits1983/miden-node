syntax = "proto3";
package requests;

import "account.proto";
import "digest.proto";
import "note.proto";

// Applies changes of a new block to the DB and in-memory data structures.
message ApplyBlockRequest {
    // Block data encoded using Miden's native format
    bytes block = 1;
}

// Returns a list of nullifiers that match the specified prefixes and are recorded in the node.
message CheckNullifiersByPrefixRequest {
    // Number of bits used for nullifier prefix. Currently the only supported value is 16.
    uint32 prefix_len = 1;
    // List of nullifiers to check. Each nullifier is specified by its prefix with length equal
    // to prefix_len
    repeated uint32 nullifiers = 2;
}

// Get a list of proofs for given nullifier hashes, each proof as a sparse Merkle Tree
message CheckNullifiersRequest {
    // List of nullifiers to return proofs for
    repeated digest.Digest nullifiers = 1;
}

// Returns the block header corresponding to the requested block number, as well as the merkle
// path and current forest which validate the block's inclusion in the chain.
//
// The Merkle path is an MMR proof for the block's leaf, based on the current chain length.
message GetBlockHeaderByNumberRequest {
    // The block number of the target block.
    //
    // If not provided, means latest known block.
    optional uint32 block_num = 1;
    // Whether or not to return authentication data for the block header.
    optional bool include_mmr_proof = 2;
}

// State synchronization request.
//
// Specifies state updates the client is interested in. The server will return the first block which
// contains a note matching `note_tags` or the chain tip. And the corresponding updates to
// `nullifiers` and `account_ids` for that block range.
message SyncStateRequest {
    // Last block known by the client. The response will contain data starting from the next block,
    // until the first block which contains a note of matching the requested tag, or the chain tip
    // if there are no notes.
    fixed32 block_num = 1;

    // Accounts' hash to include in the response.
    //
    // An account hash will be included if-and-only-if it is the latest update. Meaning it is
    // possible there was an update to the account for the given range, but if it is not the latest,
    // it won't be included in the response.
    repeated account.AccountId account_ids = 2;

    // Specifies the tags which the client is interested in.
    repeated fixed32 note_tags = 3;

    // Determines the nullifiers the client is interested in by specifying the 16high bits of the
    // target nullifier.
    repeated uint32 nullifiers = 4;
}

// Note synchronization request.
//
// Specifies note tags that client is interested in. The server will return the first block which
// contains a note matching `note_tags` or the chain tip.
message SyncNoteRequest {
    // Last block known by the client. The response will contain data starting from the next block,
    // until the first block which contains a note of matching the requested tag.
    fixed32 block_num = 1;

    // Specifies the tags which the client is interested in.
    repeated fixed32 note_tags = 2;
}

// Returns data needed by the block producer to construct and prove the next block, including
// account states, nullifiers, and unauthenticated notes.
message GetBlockInputsRequest {
    // ID of the account against which a transaction is executed.
    repeated account.AccountId account_ids = 1;
    // Array of nullifiers for all notes consumed by a transaction.
    repeated digest.Digest nullifiers = 2;
    // Array of note IDs to be checked for existence in the database.
    repeated digest.Digest unauthenticated_notes = 3;
}

// Returns the data needed by the block producer to check validity of an incoming transaction.
message GetTransactionInputsRequest {
    // ID of the account against which a transaction is executed.
    account.AccountId account_id = 1;
    // Array of nullifiers for all notes consumed by a transaction.
    repeated digest.Digest nullifiers = 2;
    // Array of unauthenticated note IDs to be checked for existence in the database.
    repeated digest.Digest unauthenticated_notes = 3;
}

// Submits proven transaction to the Miden network.
message SubmitProvenTransactionRequest {
    // Transaction encoded using Miden's native format
    bytes transaction = 1;
}

// Returns a list of notes matching the provided note IDs.
message GetNotesByIdRequest {
    // List of NoteId's to be queried from the database
    repeated digest.Digest note_ids = 1;
}

// Returns a list of Note inclusion proofs for the specified Note IDs.
message GetNoteAuthenticationInfoRequest {
    // List of NoteId's to be queried from the database
    repeated digest.Digest note_ids = 1;
}

// Lists all nullifiers of the current chain.
message ListNullifiersRequest {}

// Lists all accounts of the current chain.
message ListAccountsRequest {}

// Lists all notes of the current chain.
message ListNotesRequest {}

// Returns the latest state of an account with the specified ID.
message GetAccountDetailsRequest {
    // Account ID to get details.
    account.AccountId account_id = 1;
}

// Retrieves block data by given block number.
message GetBlockByNumberRequest {
    // The block number of the target block.
    fixed32 block_num = 1;
}

// Returns delta of the account states in the range from `from_block_num` (exclusive) to
// `to_block_num` (inclusive).
message GetAccountStateDeltaRequest {
    // ID of the account for which the delta is requested.
    account.AccountId account_id = 1;
    // Block number from which the delta is requested (exclusive).
    fixed32 from_block_num = 2;
    // Block number up to which the delta is requested (inclusive).
    fixed32 to_block_num = 3;
}

// Returns the latest state proofs of accounts with the specified IDs.
message GetAccountProofsRequest {
    // List of account IDs to get states.
    repeated account.AccountId account_ids = 1;
    // Optional flag to include header and account code in the response. `false` by default.
    optional bool include_headers = 2;
    // Account code commitments corresponding to the last-known `AccountCode` for requested 
    // accounts. Responses will include only the ones that are not known to the caller.
    // These are not associated with a specific account but rather, they will be matched against
    // all requested accounts.
    repeated digest.Digest code_commitments = 3;
}
